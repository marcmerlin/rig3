Rig3 Design Doc

----
20070827 Rig3

Rig3 is designed to be an over simplified version of the (dead) rig2.
Here I'll first explain the main goal and then stages to get there, with the
idea that the first stages will be as simple as possible to get started asap.

Rig3 is not a server. It's a standalone python script that runs periodically
on the server, parsing a directory tree that contains pictures and Izu files.
It produces another directory tree ready to be served by Apache. The main
target is to run this under Linux. Whenever possible make it OS agnostic
(by using os.path.sep f.ex.)

Whenever possible, the processing is going to be incremental, meaning one can
expect that most of the source won't have changed between two invocations.
It is thus essential to detect only what has changed and rebuild only what is
necessary.

There are two parts in Rig3:
- The engine part is about processing files.
- The application part is about generating the final content we care for.

Both parts work together. The engine is just here to do whatever the application
needs, and not much more.

So let's see what application we want to do first:
- The main output is a weblog, aka blog, with an entry page containing the
  last N new items.
- Each item is either an Izumi text file (with possible images inserted)
  or an album view.
- The source folders are organized as a hierarchy of directories with a date
  (either explicit from the folder name or implicit from the filesystem).
- Each folder is a blog item and in the blog the structure is flat.
- Parents folders are used to provide categories and index.izu files (or some kind of
  specific file) can provide additional tags.
- Generated pages:
	- Page for the Most recent N items
	- Page for all items of category X
- Each item should be generated as a bit of HTML, cached as an embeddable HTML file.
- Each page is a collection of existing items. We can use .shtml on the server
  side (to be enabled in Apache) to link the separate items into a single page,
  or we could use AJAX. We'll start with the shtml approach for simplicity.
- Use KID for templating the pages and the items.

The engine should work like this:
- First build a list of source folders to process and their associated
  destination. These objects should be "lazy" and not load their content
  unless really needed.
- Detect which folders have changed, ideally using some simple heuristic
  such as the modification time.
- Create or update the items corresponding to the changed folders.
- Create or update the pages corresponding to the changed items.

Stages:
- Stage 1:
	- Ignore pictures (i.e. the album view will be a link to an existing
	  Rig1) and only deal with folders that contain an index.izu.
  	- Requires a new Izu formatter in Python that can embedded the Rig images.
  	- Have global config vs sites configs.
  		- Patterns for valid folder names
  		- Settings for generating the Rig links
  	- Generate .shtml for items and create pages that uses them.
- Stage 2:
	- Remove obsolete destination items/pages
	- Generate embedded album views, with a link onto the full rig version.
		- Settings/patterns for image levels (unwanted/ignored, low/medium/good/excellent)
	- Experiment with AJAX instead of shtml (or provide it as an option)
	- Tags to be able to remove a given source folder from processing
	- Tags to generate .htaccess into destination

Expansions:
- Ability to generate on-the-fly obfuscated pages for sharing
	- can be done at first by symlinking the html on the web server

----
20070827 Structure Stage 1

At root level:
rig3/src: all.
rig3/misc: this file.
rig3/rig3.py -> src/rig3.py

At src level:
- settings.py: Load() from .rig3.rc f.ex (flat settings dict per site)
- dirparser.py: Parse(dir) => list [ Dir( ... ) ] (recursive)
- generate.py: Generate(site)
	- load source for site
	- compare to dest
	- generate or update items
	- keep links per type: last-n-page or page-cat-X (dict of list or dict of dict)
	- generate pages
- izumi.py: ConvertToHtml(izu)
- thumbnail.py: UrlForImage(file, quality, size)
- cache.py: Store(type, name, ref), or update. Cleanup()

----
20071020 Template System

I started using the Kid XML Templating system and I'm not very happy with it.
It's a fine piece of software and it does its job right. It's just not what I
really want. One one hand it means templates have to be XML whereas I want
templates to very free text. On the other hand by default it comes with a
limited set of serializers, most pro-eminently XML or HTML, that is it will
reformat documents accordingly -- and same here I just want something that
does text replacement in a template, not reformatting.

In the past I used the Django templating system with success and I liked it
overall. It's only weakness is that it doesn't do HTML encoding by default, but
that normal since it doesn't /have/ to be HTML templates. However Django does
much more than just templates and I don't need all the rest.

So I decided I will re-implement a minimalist templating system that does
exactly and only what I need. The specs follow.

Templates are free text with simple variable replacement.

Templates contain tags, which are enclosed in double-bracket pairs: [[ ... ]]
The first word after the opening bracket is the operation. Some tags can contain
content, in which case the content will be after the tag and before the next
[[end]] tag.

By default we'll have:
- [[# multi-line comment]]
- [[for x in list]] ... [[end]]
- [[include template.name]]
- [[if cond]] ... [[else]] ... [[end]]
- [[variable|filter|filter]]

Unknown tag operations will be expected to be variables to be replaced in place,
possibly after filtering.

Variable expansion should also accept field access, e.g. var.property.value.
For list, list.index (e.g. mylist.0); for dictionaries do a get; if property
is a function it evaluates it without arguments; otherwise it's a field/property
access.

If the template extension is ".html", variables will by default be html-encoded
unless a filter is present.

The expected filters will be:
- raw: The string is output as such. It's a no-op.
- html: HTML-encode the string. This is an implicit filter for .html templates.
- url: URL-encode the string.
- %: Any of the "printf"-like formatting for strings (e.g.: [[count|%02x]]

If you're familiar with Django, you'll notice this is basically the same
templating system except it doesn't have the notion of "top template" with
overridable blocks -- I prefer the usual top-down inclusion system.

There could be potentially more tag operations and more filters, for example
an "inc" filter, [[elseif]], date formatting, etc.


Implementation: we just want one class, Template(filename).
Included templates will be looked up in the same directory.
The Template constructor should parse the template and validate it and thow
a ParseException if needed.
Then Template.generate(dictionary) will serialize the template to a string.

Internally we shall parse the template into a structured tree.
A node can be:
- a list of nodes
- literal: content
- tag: tag name, parameters, optional node content
- variable: name list (e.g. x.y.z), filter list


Limitations: to keep things simply, we won't have variable expansion inside
tag blocks. E.g. you can't write [[for x in [[y.somelist]]]], nor can you
write [[myvar.[[selector]]]]. If we really had to, it wouldn't be too hard
to support, but my experience is that this is rarely needed and I don't see the
need for it -- I'm not writing the most universal templating system here, just
the minimum for what I need.
 

----
20071029 Template System, revisited

I finalized a first shot at the implementation of the template system.

I ended up implementing these tags:
- [[# comment]]
- [[for var in expr]] ... [[end]]
- [[if expr]] ... [[end]]
- [[expr]]
 
Note that "expr" is exactly that: a free string evaluated as a python expression.
For the "for", it's expected to return some iteratable (generator or list), for "if" it's
interpreted as a boolean using "not not x" and the last one mean that any unrecognized tag
is interpreted as an expression and then replaced as a string.

Note the lack of [[else]] and [[elif]]. These are not really needed, just use several "if" tags.

Initially I wanted to have filters a-la-Django for the free expressions, i.e. I wanted:
- [[expr|raw]]
- [[expr|html]]
- [[expr|url]]
With filter chaining, so you could say [[number|inc|html]].

However it's not really needed. Filters are just a Django idiom to call functions in a syntax
that doesn't allow it. Instead you can just have a global "inc()" function and call it.
I do want the raw/html/url encoding made explicit however, so I'm going to force them to
create expression evaluation. [[expr]] is going away and being replaced by:
- [[raw expr]]
- [[html  expr]]
- [[url expr]]

This also forces the template designer to make sure s/he's aware of when escaping is
done... or not.

Finally, I'm please with the free evaluation. It's much more elegant and convenient that
forcing a syntax for variables and "if" tags. It has two downsides: first it makes it easier
for a template designer to break the separation between code and template (i.e. the
dogma of having no code in templates) and second it can be too powerful and be exploited,
there's not much of a sandbox here. If you are developing a large-scale templating system
like Django, these matter a lot. In my case, I prefer the expressiveness since I'm both the
engine designer and the application designer, *and* my target is static sites generation.

----
20071029 Application

Now that the engine "framework" part of rig3 is more or less operational, even if very crude,
it's time to focus on the application at hand.

Each directory that contains a valid entry should have:
- an index.izu or an index.html
- zero or more photos

Right now I'll ignore directories without an index (it can be empty although
ideally I should have something.) Later I may add a more just for pictures.

The index.html is for importing old entries from the previous blog.
They are self contained and already contain pictures link as necessary. They
are just imported as-is. However the index.html also contain an "izu header"
on its first line (hidden in an html comment).
The izu parser should be able to handle that and generate the tags as
appropriate. Currently this header contains:
- The full date (YMD/HMS) of the original post
- The title
- A category (currently empty because of a bug but can be fixed). Or more
  exactly a list of category keywords.
- The author's name 

The izu index should have the following structure:
- An izu header on the first line (same tags).
	- The date & title are optional.
	- If not present, the defaults extracted from the directory name will be used.
  	- If present, they must override these defaults.
- Sections: "en" (english), "fr" (french), "images", "notes".
  	- Sections are optional. "en" is the default if not specified.
	- Sections are to be used in the template if present.

The purpose of the sections is to further separate layout from content:
even in the current HTML of the "old" wordpress blog, I have quite a bit of
layout encoded in each post. By separating the layout, I can change the way
sections are displayed after the fact, without having to edit back each entry.

Some sections might be specialized. For example I'd like to have an "images"
section with a list of images to display in this post and some layout logic that
can display the images differently (for example a slideshow vs a grid, etc.)

We'll start with a minimum set of izu tags and will expand later as needed.

For the structure:
- [izu:title:xyz]
- [izu:date:YYYY/MM/DD HH:MM:SS]
- [izu:author:xyz]
- [izu:cat:xyz1,xyz2,...] -- for catagories, can be empty
- [izu:refuse] -- don't serve this entry at all, can be used for temporary stuff
- [s:(en|fr|images|notes)] -- unknown sections should generate a warning
- [!-- .. --] -- comments

For izu tags (title, date, etc.), several version can be present. The last
one takes precedence. However it should be customary to just place them on
the first line.

For the presentation:
- __bold__
- ''italics''
- new lines for paragraphs
- * for lists, without indentation. A list ends when there's an empty line.
- ---- for an <hr>
- [title|url] -- for links or images.
- [rig:url:size] -- to generate a rig link

For list, I'll try something different. First I won't implement indentation
in the first shot (will have to be later, when needed.) And a bullet-point list
will keep going till there's an empty line. That means each entry in the list
can be multi-line as long as it doesn't start with a star.

The [rig] tag will generate a thumbnail of the requested size with a link
onto the album (or the image?).

So this is the "design summary". Later I'll probably want to add some more tags,
support for block indentation and tables for example. That will wait till it
becomes needed though.

----
20071031 Izu Implementation

Tags implementation should happen in this order:
- comments (because it's easy)
- paragraphs
- bold and italics
- sections

----
20071103 Izu Implementation

Now I need tags for links/image inclusing, rig images and the application
specific code for images.

The image handle is an application logic, not a framework logic.
At the framework part, there's nothing needed. An [s:images] section is currently
implemented but I won't use it, so I might remove it.

Instead what happens is that at the site level, when parsing one entry, we get a
list of images. They have a specific name pattern, right now I use (pseudo-regexp):
 ([A-Z][0-9]+)([ ._-+])(name).(jpe?g|.web.wmv|.web.mov|.original.mov)
where the groups mean:
 (index)      (rating) (name) (extension)

The index is composed of a letter (camera's owner) and a unique index for the camera.
An optional "p" can follow for a panorama.
The rating mean:
- no rating: space (I tend to avoid this)
- poor: a dot
- normal: an underscore
- good: a dash
- excellent: a plus

For a given index, there might be several images which varying extensions.
Typically for movies I have:
- a thumbnail: .jpg
- a web .mov and a web .wmv in low quality
- the full MJPEG as original.mov

The first idea is to have an heuristic as follow:
- if there are any + ratings, show these images as medium size (i.e. 300-400 pixels)
- if there are some - ratings, show these as thumbnails (say 64 pixels)
- otherwise show nothing
If any of the +/- ratings are movies (.mov/.wmv), show the .jpg thumbnail instead if it exists.
  

----
20071104 Site vs template logic

Speaking of which, I should separate the generic code for parsing/generating
a site from the code that actually generates the templates.

Currently what gets generated is:
- the content for each entry
- a set of index pages that contain N entries

Because the index actually contains the text, I don't need the entries as
files on the side. This was originally done because I though I could have
the index using server-side html include (.shtml) for each entry. Indeed it
can, but right now it's not worth it: this makes it a lot more work for
Apache to server a page, as it needs to read N+1 files instead of one index
file.

Similarly we could have the index contain "ajax" (asynchronous javascript) calls
to read each entry and replace a div. This also means more load for the server.

The only benefit of this scheme is if I want to have several indexes: one for
the most recent, one per category, one per month/year, etc. In this case, if there are
thousand of entries that are going to be copied in a dozen indexes, it *may* make sense
to overall size at the detriment of a longer page load and heavier server load.

However in my case, disk space is mostly irrelevant and server cpu is at a premium,
so I will prefer to have full indexes. Consequently I don't need to generate each
entry in a separate file.

Eventually, each template should be able to choose from. That's why I need to
refactor the Site class: part of the logic is template dependent and should be
handled as such. 

----
20071121 Next Steps

- Permalinks
	- Ironically, requires to save each post as a separate HTML file
	- links: prev/next/up. Up goes to the corresponding index with an anchor.
- RSS generation
	- discovery links
- Site customization/refactor.
	- Ability to have several sources. Each source generates a dated list of entries.
		- DirParser is just one of them.
		- Adapt DirParser to return single files w/ pattern <date><title>.izu
		- Later I'll want a parser for old izu files that contain multiple entries.
		- It can be all done by DirParser but we want to make it configurable in
			site prefs.
	- Move prefs to site prefs w/ defaults. Essentially regexps but also Rig sizes.
	- Extract actual page/items/images generation.
- IzuParser:
	- add a raw HTML tag, to include HTML inline on the spot, e.g. [html:-- ... --].
	- [img:] tag that work for current album (or simply [blah.jpg])
- Documentation

The long term goal is that it should be possible to switch templates *and* switch the
actual page generation with the template. On the other hand, this may be too tighted-in
to be practical. Still we can offset the page generation to an helper class and maybe
have different ones depending on the template.

Some more changes needed by MM:
- List categories to be included and/or excluded from automatic generation
- For some categories, mark them as "private" and remove links to main blog.
- Generate a TOC on top or bottom of some pages.
 
One way to do this is to specify site prefs:
- Which indexes to generate: index, rss, public_cat, private_cat (cat=categories)
- What are public categories: all, cat1, cat2... all is a special keyword here, it's the default.
- What are private categories: cat1, cat2... default is empty.
Private categories generate index pages without any reference on the main blog.
We may want to have a special destination for them.

Another way to do this is to use different sites, that read from the same source but
output to different destinations. In each site, we'll have list of categories to accept
(default being to accept "all") and then a boolean flag indicating how to treat links.

----
20071123 Site Settings

Existing site settings:
- public_name="", public name of blog (for templates to display)
- source_dir=string, path of source directory (absolute or relative)
- dest_dir=None, path of output directory (absolute or relative)
- theme=DEFAULT_THEME, string of theme directory
- base_url="http://html.base.url/", for templates which want to use it
- rig_url="http://rig.base.url/photos/", for generating rig links
- header_img_url="", to replace the default header image in the default template
- tracking_code="", a raw html piece for google analytics or similar

New site settings:
- rig_url: Obsoleted.
- rig_img_url: string format with <album> and <img> parameters
- rig_album_url: string format with <album> parameter
- link_to_rig_album: False. Should images link to the rig album?
- link_to_rig_img: True. Should images link to the corresponding rig image? 
- category_filter: None or list of category names (strings, case-insensitive) to accept
- permalinks: True. Boolean, true if should have permalinks
- toc: False. Boolean, true if we want a TOC at the top of the index
- rss: True. Boolean, generate an RSS feed.

----
20071201 

I need a way to split the rig.Site class in two parts, but so far I lack a clear
terminology for it so let's try:
- SiteBase: A base class for the Site, partially abstract. A couple methods need to be
  implemented by the derived classes. As such it offers the "contract" needed to generate a
  site, with a default to parse content, but it lacks the actual generation code, which is
  template dependent (i.e. which template files to call, with which parameters)
- SiteDefault: The "default" template implementation. It provides the GeneratePages and
  GenerateItem implementation for the default template.

This will work. The only limitation right now is that the template's specific Site
class is in the rig namespace. We need a better location if we want the ability for
end-users to add new templates. As long as I don't have dynamic loading of arbitrary
python source classes outside of the default namespace, it's going to be a bit difficult.
I've done that with rig2 and didn't like it, so I'll start with a low-tech approach
which is to have a rig.site namespace (aka directory) and we'll evolve from there.

So to resume:
- before: rig/site.py => rig.site.Site
- after:  rig/site_base.py => rig.site_base.SiteBase
        + rig/site/site_default.py => rig.site.default.SiteDefault
and there's a "factory" constructor in rig.site.CreateSite() that returns the correct
Site-derived class depending on the template name.

