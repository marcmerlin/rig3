Rig3 Design Doc

----
20070827 Rig3

Rig3 is designed to be an over simplified version of the (dead) rig2.
Here I'll first explain the main goal and then stages to get there, with the
idea that the first stages will be as simple as possible to get started asap.

Rig3 is not a server. It's a standalone python script that runs periodically
on the server, parsing a directory tree that contains pictures and Izu files.
It produces another directory tree ready to be served by Apache. The main
target is to run this under Linux. Whenever possible make it OS agnostic
(by using os.path.sep f.ex.)

Whenever possible, the processing is going to be incremental, meaning one can
expect that most of the source won't have changed between two invocations.
It is thus essential to detect only what has changed and rebuild only what is
necessary.

There are two parts in Rig3:
- The engine part is about processing files.
- The application part is about generating the final content we care for.

Both parts work together. The engine is just here to do whatever the application
needs, and not much more.

So let's see what application we want to do first:
- The main output is a weblog, aka blog, with an entry page containing the
  last N new items.
- Each item is either an Izumi text file (with possible images inserted)
  or an album view.
- The source folders are organized as a hierarchy of directories with a date
  (either explicit from the folder name or implicit from the filesystem).
- Each folder is a blog item and in the blog the structure is flat.
- Parents folders are used to provide categories and index.izu files (or some kind of
  specific file) can provide additional tags.
- Generated pages:
	- Page for the Most recent N items
	- Page for all items of category X
- Each item should be generated as a bit of HTML, cached as an embeddable HTML file.
- Each page is a collection of existing items. We can use .shtml on the server
  side (to be enabled in Apache) to link the separate items into a single page,
  or we could use AJAX. We'll start with the shtml approach for simplicity.
- Use KID for templating the pages and the items.

The engine should work like this:
- First build a list of source folders to process and their associated
  destination. These objects should be "lazy" and not load their content
  unless really needed.
- Detect which folders have changed, ideally using some simple heuristic
  such as the modification time.
- Create or update the items corresponding to the changed folders.
- Create or update the pages corresponding to the changed items.

Stages:
- Stage 1:
	- Ignore pictures (i.e. the album view will be a link to an existing
	  Rig1) and only deal with folders that contain an index.izu.
  	- Requires a new Izu formatter in Python that can embedded the Rig images.
  	- Have global config vs sites configs.
  		- Patterns for valid folder names
  		- Settings for generating the Rig links
  	- Generate .shtml for items and create pages that uses them.
- Stage 2:
	- Remove obsolete destination items/pages
	- Generate embedded album views, with a link onto the full rig version.
		- Settings/patterns for image levels (unwanted/ignored, low/medium/good/excellent)
	- Experiment with AJAX instead of shtml (or provide it as an option)
	- Tags to be able to remove a given source folder from processing
	- Tags to generate .htaccess into destination

Expansions:
- Ability to generate on-the-fly obfuscated pages for sharing
	- can be done at first by symlinking the html on the web server

----
20070827 Structure Stage 1

At root level:
rig3/src: all.
rig3/misc: this file.
rig3/rig3.py -> src/rig3.py

At src level:
- settings.py: Load() from .rig3.rc f.ex (flat settings dict per site)
- dirparser.py: Parse(dir) => list [ Dir( ... ) ] (recursive)
- generate.py: Generate(site)
	- load source for site
	- compare to dest
	- generate or update items
	- keep links per type: last-n-page or page-cat-X (dict of list or dict of dict)
	- generate pages
- izumi.py: ConvertToHtml(izu)
- thumbnail.py: UrlForImage(file, quality, size)
- cache.py: Store(type, name, ref), or update. Cleanup()

----
20071020 Template System

I started using the Kid XML Templating system and I'm not very happy with it.
It's a fine piece of software and it does its job right. It's just not what I
really want. One one hand it means templates have to be XML whereas I want
templates to very free text. On the other hand by default it comes with a
limited set of serializers, most pro-eminently XML or HTML, that is it will
reformat documents accordingly -- and same here I just want something that
does text replacement in a template, not reformatting.

In the past I used the Django templating system with success and I liked it
overall. It's only weakness is that it doesn't do HTML encoding by default, but
that normal since it doesn't /have/ to be HTML templates. However Django does
much more than just templates and I don't need all the rest.

So I decided I will re-implement a minimalist templating system that does
exactly and only what I need. The specs follow.

Templates are free text with simple variable replacement.

Templates contain tags, which are enclosed in double-bracket pairs: [[ ... ]]
The first word after the opening bracket is the operation. Some tags can contain
content, in which case the content will be after the tag and before the next
[[end]] tag.

By default we'll have:
- [[# multi-line comment]]
- [[for x in list]] ... [[end]]
- [[include template.name]]
- [[if cond]] ... [[else]] ... [[end]]
- [[variable|filter|filter]]

Unknown tag operations will be expected to be variables to be replaced in place,
possibly after filtering.

Variable expansion should also accept field access, e.g. var.property.value.
For list, list.index (e.g. mylist.0); for dictionaries do a get; if property
is a function it evaluates it without arguments; otherwise it's a field/property
access.

If the template extension is ".html", variables will by default be html-encoded
unless a filter is present.

The expected filters will be:
- raw: The string is output as such. It's a no-op.
- html: HTML-encode the string. This is an implicit filter for .html templates.
- url: URL-encode the string.
- %: Any of the "printf"-like formatting for strings (e.g.: [[count|%02x]]

If you're familiar with Django, you'll notice this is basically the same
templating system except it doesn't have the notion of "top template" with
overridable blocks -- I prefer the usual top-down inclusion system.

There could be potentially more tag operations and more filters, for example
an "inc" filter, [[elseif]], date formatting, etc.


Implementation: we just want one class, Template(filename).
Included templates will be looked up in the same directory.
The Template constructor should parse the template and validate it and thow
a ParseException if needed.
Then Template.generate(dictionary) will serialize the template to a string.

Internally we shall parse the template into a structured tree.
A node can be:
- a list of nodes
- literal: content
- tag: tag name, parameters, optional node content
- variable: name list (e.g. x.y.z), filter list


Limitations: to keep things simply, we won't have variable expansion inside
tag blocks. E.g. you can't write [[for x in [[y.somelist]]]], nor can you
write [[myvar.[[selector]]]]. If we really had to, it wouldn't be too hard
to support, but my experience is that this is rarely needed and I don't see the
need for it -- I'm not writing the most universal templating system here, just
the minimum for what I need.
 

----
20071029 Template System, revisited

I finalized a first shot at the implementation of the template system.

I ended up implementing these tags:
- [[# comment]]
- [[for var in expr]] ... [[end]]
- [[if expr]] ... [[end]]
- [[expr]]
 
Note that "expr" is exactly that: a free string evaluated as a python expression.
For the "for", it's expected to return some iteratable (generator or list), for "if" it's
interpreted as a boolean using "not not x" and the last one mean that any unrecognized tag
is interpreted as an expression and then replaced as a string.

Note the lack of [[else]] and [[elif]]. These are not really needed, just use several "if" tags.

Initially I wanted to have filters a-la-Django for the free expressions, i.e. I wanted:
- [[expr|raw]]
- [[expr|html]]
- [[expr|url]]
With filter chaining, so you could say [[number|inc|html]].

However it's not really needed. Filters are just a Django idiom to call functions in a syntax
that doesn't allow it. Instead you can just have a global "inc()" function and call it.
I do want the raw/html/url encoding made explicit however, so I'm going to force them to
create expression evaluation. [[expr]] is going away and being replaced by:
- [[raw expr]]
- [[html  expr]]
- [[url expr]]

This also forces the template designer to make sure s/he's aware of when escaping is
done... or not.

Finally, I'm please with the free evaluation. It's much more elegant and convenient that
forcing a syntax for variables and "if" tags. It has two downsides: first it makes it easier
for a template designer to break the separation between code and template (i.e. the
dogma of having no code in templates) and second it can be too powerful and be exploited,
there's not much of a sandbox here. If you are developing a large-scale templating system
like Django, these matter a lot. In my case, I prefer the expressiveness since I'm both the
engine designer and the application designer, *and* my target is static sites generation.

----
20071029 Application

Now that the engine "framework" part of rig3 is more or less operational, even if very crude,
it's time to focus on the application at hand.

Each directory that contains a valid entry should have:
- an index.izu or an index.html
- zero or more photos

Right now I'll ignore directories without an index (it can be empty although
ideally I should have something.) Later I may add a more just for pictures.

The index.html is for importing old entries from the previous blog.
They are self contained and already contain pictures link as necessary. They
are just imported as-is. However the index.html also contain an "izu header"
on its first line (hidden in an html comment).
The izu parser should be able to handle that and generate the tags as
appropriate. Currently this header contains:
- The full date (YMD/HMS) of the original post
- The title
- A category (currently empty because of a bug but can be fixed). Or more
  exactly a list of category keywords.
- The author's name 

The izu index should have the following structure:
- An izu header on the first line (same tags).
	- The date & title are optional.
	- If not present, the defaults extracted from the directory name will be used.
  	- If present, they must override these defaults.
- Sections: "en" (english), "fr" (french), "images", "notes".
  	- Sections are optional. "en" is the default if not specified.
	- Sections are to be used in the template if present.

The purpose of the sections is to further separate layout from content:
even in the current HTML of the "old" wordpress blog, I have quite a bit of
layout encoded in each post. By separating the layout, I can change the way
sections are displayed after the fact, without having to edit back each entry.

Some sections might be specialized. For example I'd like to have an "images"
section with a list of images to display in this post and some layout logic that
can display the images differently (for example a slideshow vs a grid, etc.)

We'll start with a minimum set of izu tags and will expand later as needed.

For the structure:
- [izu:title:xyz]
- [izu:date:YYYY/MM/DD HH:MM:SS]
- [izu:author:xyz]
- [izu:cat:xyz1,xyz2,...] -- for catagories, can be empty
- [izu:refuse] -- don't serve this entry at all, can be used for temporary stuff
- [s:(en|fr|images|notes)] -- unknown sections should generate a warning
- [!-- .. --] -- comments

For izu tags (title, date, etc.), several version can be present. The last
one takes precedence. However it should be customary to just place them on
the first line.

For the presentation:
- __bold__
- ''italics''
- new lines for paragraphs
- * for lists, without indentation. A list ends when there's an empty line.
- ---- for an <hr>
- [title|url] -- for links or images.
- [rig:url:size] -- to generate a rig link

For list, I'll try something different. First I won't implement indentation
in the first shot (will have to be later, when needed.) And a bullet-point list
will keep going till there's an empty line. That means each entry in the list
can be multi-line as long as it doesn't start with a star.

The [rig] tag will generate a thumbnail of the requested size with a link
onto the album (or the image?).

So this is the "design summary". Later I'll probably want to add some more tags,
support for block indentation and tables for example. That will wait till it
becomes needed though.

----
20071031 Izu Implementation

Tags implementation should happen in this order:
- comments (because it's easy)
- paragraphs
- bold and italics
- sections

----
20071103 Izu Implementation

Now I need tags for links/image inclusing, rig images and the application
specific code for images.

The image handle is an application logic, not a framework logic.
At the framework part, there's nothing needed. An [s:images] section is currently
implemented but I won't use it, so I might remove it.

Instead what happens is that at the site level, when parsing one entry, we get a
list of images. They have a specific name pattern, right now I use (pseudo-regexp):
 ([A-Z][0-9]+)([ ._-+])(name).(jpe?g|.web.wmv|.web.mov|.original.mov)
where the groups mean:
 (index)      (rating) (name) (extension)

The index is composed of a letter (camera's owner) and a unique index for the camera.
An optional "p" can follow for a panorama.
The rating mean:
- no rating: space (I tend to avoid this)
- poor: a dot
- normal: an underscore
- good: a dash
- excellent: a plus

For a given index, there might be several images which varying extensions.
Typically for movies I have:
- a thumbnail: .jpg
- a web .mov and a web .wmv in low quality
- the full MJPEG as original.mov

The first idea is to have an heuristic as follow:
- if there are any + ratings, show these images as medium size (i.e. 300-400 pixels)
- if there are some - ratings, show these as thumbnails (say 64 pixels)
- otherwise show nothing
If any of the +/- ratings are movies (.mov/.wmv), show the .jpg thumbnail instead if it exists.
  

----
20071104 Site vs template logic

Speaking of which, I should separate the generic code for parsing/generating
a site from the code that actually generates the templates.

Currently what gets generated is:
- the content for each entry
- a set of index pages that contain N entries

Because the index actually contains the text, I don't need the entries as
files on the side. This was originally done because I though I could have
the index using server-side html include (.shtml) for each entry. Indeed it
can, but right now it's not worth it: this makes it a lot more work for
Apache to server a page, as it needs to read N+1 files instead of one index
file.

Similarly we could have the index contain "ajax" (asynchronous javascript) calls
to read each entry and replace a div. This also means more load for the server.

The only benefit of this scheme is if I want to have several indexes: one for
the most recent, one per category, one per month/year, etc. In this case, if there are
thousand of entries that are going to be copied in a dozen indexes, it *may* make sense
to overall size at the detriment of a longer page load and heavier server load.

However in my case, disk space is mostly irrelevant and server cpu is at a premium,
so I will prefer to have full indexes. Consequently I don't need to generate each
entry in a separate file.

Eventually, each template should be able to choose from. That's why I need to
refactor the Site class: part of the logic is template dependent and should be
handled as such. 

----
20071121 Next Steps

- Permalinks
	- Ironically, requires to save each post as a separate HTML file
	- links: prev/next/up. Up goes to the corresponding index with an anchor.
- RSS generation
	- discovery links
- Site customization/refactor.
	- Ability to have several sources. Each source generates a dated list of entries.
		- DirParser is just one of them.
		- Adapt DirParser to return single files w/ pattern <date><title>.izu
		- Later I'll want a parser for old izu files that contain multiple entries.
		- It can be all done by DirParser but we want to make it configurable in
			site prefs.
	- Move prefs to site prefs w/ defaults. Essentially regexps but also Rig sizes.
	- Extract actual page/items/images generation.
- IzuParser:
	- add a raw HTML tag, to include HTML inline on the spot, e.g. [html:-- ... --].
	- [img:] tag that work for current album (or simply [blah.jpg])
- Documentation

The long term goal is that it should be possible to switch templates *and* switch the
actual page generation with the template. On the other hand, this may be too tighted-in
to be practical. Still we can offset the page generation to an helper class and maybe
have different ones depending on the template.

Some more changes needed by MM:
- List categories to be included and/or excluded from automatic generation
- For some categories, mark them as "private" and remove links to main blog.
- Generate a TOC on top or bottom of some pages.
 
One way to do this is to specify site prefs:
- Which indexes to generate: index, rss, public_cat, private_cat (cat=categories)
- What are public categories: all, cat1, cat2... all is a special keyword here, it's the default.
- What are private categories: cat1, cat2... default is empty.
Private categories generate index pages without any reference on the main blog.
We may want to have a special destination for them.

Another way to do this is to use different sites, that read from the same source but
output to different destinations. In each site, we'll have list of categories to accept
(default being to accept "all") and then a boolean flag indicating how to treat links.

----
20071123 Site Settings

Existing site settings:
- public_name="", public name of blog (for templates to display)
- source_dir=string, path of source directory (absolute or relative)
- dest_dir=None, path of output directory (absolute or relative)
- theme=DEFAULT_THEME, string of theme directory
- base_url="http://html.base.url/", for templates which want to use it
- rig_url="http://rig.base.url/photos/", for generating rig links
- header_img_url="", to replace the default header image in the default template
- tracking_code="", a raw html piece for google analytics or similar

New site settings:
- rig_url: Obsoleted.
- rig_img_url: string format with <album> and <img> parameters
- rig_album_url: string format with <album> parameter
- link_to_rig_album: False. Should images link to the rig album?
- link_to_rig_img: True. Should images link to the corresponding rig image? 
- category_filter: None or list of category names (strings, case-insensitive) to accept
- permalinks: True. Boolean, true if should have permalinks
- toc: False. Boolean, true if we want a TOC at the top of the index
- rss: True. Boolean, generate an RSS feed.

----
20071201 Site Refactor 

I need a way to split the rig.Site class in two parts, but so far I lack a clear
terminology for it so let's try:
- SiteBase: A base class for the Site, partially abstract. A couple methods need to be
  implemented by the derived classes. As such it offers the "contract" needed to generate a
  site, with a default to parse content, but it lacks the actual generation code, which is
  template dependent (i.e. which template files to call, with which parameters)
- SiteDefault: The "default" template implementation. It provides the GeneratePages and
  GenerateItem implementation for the default template.

This will work. The only limitation right now is that the template's specific Site
class is in the rig namespace. We need a better location if we want the ability for
end-users to add new templates. As long as I don't have dynamic loading of arbitrary
python source classes outside of the default namespace, it's going to be a bit difficult.
I've done that with rig2 and didn't like it, so I'll start with a low-tech approach
which is to have a rig.site namespace (aka directory) and we'll evolve from there.

So to resume:
- before: rig/site.py => rig.site.Site
- after:  rig/site_base.py => rig.site_base.SiteBase
        + rig/site/site_default.py => rig.site.default.SiteDefault
and there's a "factory" constructor in rig.site.CreateSite() that returns the correct
Site-derived class depending on the template name.

----
20071202 Sources

In the configuration .rc file, the "source_dir" argument should change.
The new proposed syntax is:

 sources = [ <type>: <path> | <name> ], *

There can be more than one source, comma separated.
Each entry is either:
- a type followed by a path.
  Type is one of all | dirItems | fileItems | izuBlog.
  The path can't contain a comma in this case.
- a name, in which case another entry which that name is looked for in the
  input rc. That entry also has format "type: path" but in this case the
  path can contain a comma (since it's not a separator)

Internally, SiteSettings.source_dir becomes sources, which has type:
 list [ SourceReader ]
with:
 class SourceReader() => SourceReader(path)
 class IzuBlogReader(SourceReader)
 class DirItemsReader(SourceReader)
 class FileItemsReader(SourceReader)

Note: actual class names will be SourceReaderBase, SourceDirReader, SourceFileReader
and SourceIzuBlogReader.

----
20071215 Sources Variation

Here's a variation on the way sources are to be specified in the config.rc file:

To specify source(s), you need to add one or more "sources" variables.
Each variable contains one or more 'type: path' entries, separated by commas.
If you need to use a comma in the path, place the path in double-quotes.

Type is one of all | dirs | files | blogs:
 - "dirs": Each entry is stored in a directory which name is "date title",
           The directory must contain an "index.izu" to be valid.
 - "files": Each entry is stored in a separate file which name is "date title.izu"
 - "blogs": Entries are grouped *.izu files with an [izu:blog] header. Each file
           represents a blog category.

The type "all" is an alias for "all the other source readers for this path".
It is /really/ a shortcut to entering the same path 3 times with the different
specific types. As a side effect, rig3 will read the path recursively *three*
times. So unless you really mean that, use a specific type for a given path.

Since duplicate variable names cannot be used, if you want multiple variables
just add a suffix to "sources". It can be anything, e.g. "sources_1" or
"sourcesABC" or "sourcesss", as long as it's a valid variable name. Sources
variables are processed in lexicographical order.

Example:

 sources = all: /home/user/izu_files, dirs: /my/dir, files: "/my,files/", files: /my/files2
 sources2 = all: /more/stuff
 sources_001 = all: /even/more/stuff
 sourcesStuff = all: /some/stuff

----
20080113 Partial Updates

One of the initial design goals was to perform "partial" updates, i.e.
make sure the minimum is updated each time rig3 runs. Originally I even
thought it should be "incremental" updates.

There's currently no support for this at all. There's a vague attempt at
deciding if source directories need to be updated, but the reality is that
the current implementation can't do it: this is done when the source
directories are parsed, and there is no knowledge of what will be generated
at that point, so no comparison can be made.

So let's revisit the issue.

First, what content is generated and how?
Currently we can read "source items" from 3 kind of sources: an item can
originate from a directory (composed of an index and images), or a single
file, or it can be a multi-item file (aka izumi blogs). There's a parser
that visits the sources and generates an internal list of items. These items
''will'' correspond to one generated "blog item", yet that logic is isolated
in the site generation.

So the notion of "partial" update does not matter at the source-reading level.
Whatever needs to be generated, we need to know what source items we have first.
For directory and single-file-based items, this is not really an issue since
the intermediate item doesn't contain any content, just a file name.
For multi-item files like izumi blogs, that's more of a concern since we do
need to actually parse the file to generate the multiple intermediate items.

Now, the default site generator takes all these intermediate items and maps
them to a single final "site item" (aka a blog item). However that's a two
steps process. The first one is to render the templates into HTML and the
second one is to generate the composed index pages (i.e. blog pages with N
items per page, per categories).

In this case, if a given source item has not changed, we can avoid re-generating
the templates. In the case of a multi-item file, if we knew it had not changed
we could also avoid parsing the file in the first place to get the items.
In this case, we would need to store the generated items on disk between runs
and then we could compare the timestamp between the source and the generated
item. We would still need to read the generated item, simply because the default
site logic creates inlined indexes.

However currently we do not store the intermediate generated items, so there's
no logic to compare them with the source's timestamp. Moreover, eventually
the default site will generate single HTML pages for items (for permalinks),
yet these will be full permalinks pages, with headers and co -- that is the
intermediate generated content will be inlined in the permalink template. This
will of course be on-disk, yet it's not suitable to be re-read.

That means we have the current dilema: on one hand, we can store the intermediate
content on disk just for the sake of being able to check its timestamp and re-read
it; on the other hand we just generate that content in-memory and we still need
to rewrite all the permalink pages every time.

The scenario where we write the intermediary content to disk becomes actually
more expensive: for each item that we do not regenerate, we still have to read
ant store the intermediary content, plus later we'll store also the permalink page,
so essentially it's stored N+1 times compared to the other scheme. And although
we don't recompute the template, we do need to read it back, so the memory cost
is similar. Moreover, for the kind of data that I process, generating the template
is mostly trivial and may be even cheaper than performing one more disk access.

In the second scenario where we only store the generated permalinks, we can
make a minimal optimization but not regenerating the permalink if the source
timestamp is older than the permalink and the permalink template hasn't changed
either. 

So that means that globally, partial updates are not very interesting.

There's still a case that should really be optimized: detect if the source
content has changed at all since the next generation and short circuit the
generation has much as we can. Ideally parsing an unchanged source should be
as cheap as possible, so that we can run it often.
On the destination part, this is easy, we can get the timestamp of the main
index.html, since it's guaranteed to be generated every time.
However on the source part, this is a bit more tricky: we still need to
visit all the source directories and stat their files. 

On a Linux system a file or directory has an access time (irrelevant for us),
a modification time (file written or a file created/deleted in a directory)
and status change timestamp (mostly irrelevant for us). The modification timestamp
of a directory will not change when an existing file is modified, only if files
are added or removed (this is logic if you think of a directory as a simple list
of inner files.)

So to know if a set of source directories have changed, we need the last generation
timestamp, and then we need to recursively parse the source directories till we
find at least one file that is newer than the last generation timestamp. We can
stop parsing at that point.

In the current structure, this can easily be done at the same time we build the
source item list -- at that point we do not actually read any content yet.
However that means for multi-item files, we'll just want to keep the reference to
the file but not parse it yet, we'll want to defer parsing later, possibly just
before we do the site generation (or even better, let the site generator start
the parsing so that it can optimize the case if needed.) 

Note that we should still defer the "last generation timestamp" to the actual
site generators. For most of them, they can simply get the main index.html timestamp
and return it. The whole skip-if-untouched should be done on a site-per-site basis.
 
----
20080116 Details for category_filter 

category_filter is a space-separated list of categories to include in given
site. The special symbol "*" matches all categories. The special symbol "$"
matches empty categories lists (i.e. post with no categories). A category
name can be prefixed by ! to be excluded. The order is NOT relevant.
The exclusion has precedence on the inclusion.
The default category filter (i.e. its absence) is "*", so that it matches everything.

Example: category_filter=public cats !dogs !parrots $ funny
will match all posts that have categories public or cats or funny or not category
and will exclude those which have dogs and parrots. 

Note that:
  category_filter=!dogs
and
  category_filter=* !dogs
mean the same thing: match every category, except those posts that use "dogs".

----
20080223 Pages & Entry generation

The way pages & entries have been generated has changed.

The default site generator now generates "month pages" and "index pages".
A month page contain all entries for a given month.
An index page contains the N most recent entries.

The index page also lists all the month pages for the same category set
so they need to be generated in the correct order.

Another change is that entries are no longer pre-generated. They are now
generated by the page generator.

Before, the HTML content of entries was generated when SourceItems were
converted to SiteItems by expanding both the image table template and the
entry template.

The issue is that entries should be able to get variables that depend on the
containing page, such as the relative URL to the root or the item's permalink.

To do that, the SiteDefault.GenerateItem method no longer expands the template
directly, instead it creates a lambda method stored in SiteItem that will be
called by the page generator, merging keywords specific to the current page.

The downside is that entries are generated multiple times, once per page in
which they appear, e.g. at least in the index, the corresponding month page,
each category index page and each category month page. For recent items,
that means 2+num_category*2 generations and for older items it's 1+num_category.

----
20080224 Free structures vs. typed structures

One of the good things with Python is that you don't really need typed structures,
i.e. "struct" in C/C++ or classes like in Java just to old a collection of members.

Some people like strong typing, other dislike it.
In Rig3, I use an intermediate level, which is most visible in settings:
settings are typically well exprimed as dictionaries.

However pure dictionaries have the problem that it's hard to guarantee which keys
are used. One of the good points (and bad points) of strongly typed languages is that
you ''have'' to declare the variables that will compose a structure but also their
types. Here we don't really care about the type but it's nice to know that a given
setting will contain this and that variables and that the compiler can enforce that
there is no typo in the field name, for example.

Of course you can define constant variables that will enforce which names are
being used to prevent typos, but that becomes ugly:
<some module>
  PARAM1="param1"
  PARAM2="param2"
  settings={}
  settings[PARAM1]=value
  ...
bleh!

That's where Python shines, once again, due to its simplicity: a class instance is
basically a dictionary and you can actually access this dictionary directly using
self.__dict__.

So typically I would define a settings "structure" like this:

class MySettings(object):
  def __init__(self, param1=default, param2...)
    self.param1=param1
    self.param2=param2

You can have default values expressed in the initializer.
You can access all the values as a dictionary: MySettings().__dict__
You can access the list of known variables: MySettings().__dict__.keys()
You can easily access known values with a nice syntax:
  my_settings.param1

And it's a dictionary so if you really need to dynamically add new fields... you can.

In essence, you use the language syntax as a macro and the compiler as a verifier.
Isn't that what they are for after all?

----
20080927 Revisiting Source Types, New Static Source

Currently rig3 supports 3 "source" types:
- files: A directory is given and recursively parsed for any .izu or .html file
    that has a date in its filename. They each compose one blog entry.
- dirs: A directory is given and recursively parsed for any sub-directory which
    has a date in its directory name. Each sub-directory compose one blog entry.
- blog: Also called "multi-item" .izu files. They are not implemented yet. If
    this was implemented, it would recursively scan a directory for an .izu
    file that contain a _serie_ of blog posts.

I'm thinking of merging these 3 source readers into one. The main rule of
specifying a base directory and reading it recursively remains unchanged.
The parsing rules would be:
- A sub-directory with a "date-title" name *and* that contains an "index.izu"
  is a single blog post. Its sub-directories are not scanned.
- Any .izu file is considered:
    - If its first line contains "[izu:blog]", it's a multi-item blog post(s).
    - Otherwise it's a single-item blog post.
- Any .html file is considered as a single blog post.

In all cases, the filename/directory name can contain a YYYYMMDD date, or
the file can use an [izu:date] tag inside. If it has both, the tag overrides
the filename.

This combined source reader would be tagged as the "blog" source reader.


I also plan to add a "static" source reader. Its purpose is not to generate
blog entries at all. Instead, it would generate static HTML pages mirroring
exactly the directory structure given to the reader. Izumi files would be
converted to HTML on the fly.

The purpose here is obvious: to generate the static portion of a web site
using Izumi templates and of course retain/merge existing HTML content.
I need that to migrate my current Izumi-based web site to Rig3 (amusingly
Izumi started as a simple static CMS with blog generation added after the
fact whereas rig3 started as a blog generator and now I'm adding static
site generation to it.)

There's still a few points left to resolve before I start there:
- How will cross-linking work? At some point I'll want to generate a link
  on the blog from the static side, and vice versa.
- Should the current "site generator" (aka site_default.py) be considered
  a "blog generator" and then I add a separate "static generator", or
  should I add support for static site into the current blog site?
  There might be enough similarities that keeping one generator is worth it
  despite the code getting a bit too big. OTOH refactoring/splitting might
  be non-trivial but worth it. We'll see.

----
2008093 New "blog" source type

I ended up implementing a "blog;" source type that will replace both
the "dirs:" and "files:" sources types. Those will be obsoleted soon.

The previous "dirs:" type had an issue: it was applying name filtering as
early as possible. That's nice since it means less directories are visited
but on the other hand it means you can't have accepted directories located
inside non-accepted directories.


The new "blog:" type works this way:
- All directories and files are processed recursively, independent of their
  actual filename.
- All directories which name match the <date-title> pattern are expected to
  be blog entries if they contain at least one "directoy valid file", i.e.
  a file with an extension izu, jpg or html.
- All files, wherever they are located, are expected to be blog entries if
  their name matches <date-title> and the extension is either izu or html.

This means you _could_ place file-entries inside directory-entries.
Sounds like a mess to me but your mileage may vary...

Note that with the default patterns, directories must contain an "index.izu"
to be accepted as blog entries and by default this "index.izu" will not
match a file-based blog entry since those must have the <date-title.izu> format.

As an extra bonus the 3 regex pattern files are overridable from the settings.

----


  