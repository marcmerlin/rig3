Rig3 Design Doc

----
20070827 Rig3

Rig3 is designed to be an over simplified version of the (dead) rig2.
Here I'll first explain the main goal and then stages to get there, with the
idea that the first stages will be as simple as possible to get started asap.

Rig3 is not a server. It's a standalone python script that runs periodically
on the server, parsing a directory tree that contains pictures and Izu files.
It produces another directory tree ready to be served by Apache. The main
target is to run this under Linux. Whenever possible make it OS agnostic
(by using os.path.sep f.ex.)

Whenever possible, the processing is going to be incremental, meaning one can
expect that most of the source won't have changed between two invocations.
It is thus essential to detect only what has changed and rebuild only what is
necessary.

There are two parts in Rig3:
- The engine part is about processing files.
- The application part is about generating the final content we care for.

Both parts work together. The engine is just here to do whatever the application
needs, and not much more.

So let's see what application we want to do first:
- The main output is a weblog, aka blog, with an entry page containing the
  last N new items.
- Each item is either an Izumi text file (with possible images inserted)
  or an album view.
- The source folders are organized as a hierarchy of directories with a date
  (either explicit from the folder name or implicit from the filesystem).
- Each folder is a blog item and in the blog the structure is flat.
- Parents folders are used to provide categories and index.izu files (or some kind of
  specific file) can provide additional tags.
- Generated pages:
	- Page for the Most recent N items
	- Page for all items of category X
- Each item should be generated as a bit of HTML, cached as an embeddable HTML file.
- Each page is a collection of existing items. We can use .shtml on the server
  side (to be enabled in Apache) to link the separate items into a single page,
  or we could use AJAX. We'll start with the shtml approach for simplicity.
- Use KID for templating the pages and the items.

The engine should work like this:
- First build a list of source folders to process and their associated
  destination. These objects should be "lazy" and not load their content
  unless really needed.
- Detect which folders have changed, ideally using some simple heuristic
  such as the modification time.
- Create or update the items corresponding to the changed folders.
- Create or update the pages corresponding to the changed items.

Stages:
- Stage 1:
	- Ignore pictures (i.e. the album view will be a link to an existing
	  Rig1) and only deal with folders that contain an index.izu.
  	- Requires a new Izu formatter in Python that can embedded the Rig images.
  	- Have global config vs sites configs.
  		- Patterns for valid folder names
  		- Settings for generating the Rig links
  	- Generate .shtml for items and create pages that uses them.
- Stage 2:
	- Remove obsolete destination items/pages
	- Generate embedded album views, with a link onto the full rig version.
		- Settings/patterns for image levels (unwanted/ignored, low/medium/good/excellent)
	- Experiment with AJAX instead of shtml (or provide it as an option)
	- Tags to be able to remove a given source folder from processing
	- Tags to generate .htaccess into destination

Expansions:
- Ability to generate on-the-fly obfuscated pages for sharing
	- can be done at first by symlinking the html on the web server

----
20070827 Structure Stage 1

At root level:
rig3/src: all.
rig3/misc: this file.
rig3/rig3.py -> src/rig3.py

At src level:
- settings.py: Load() from .rig3.rc f.ex (flat settings dict per site)
- dirparser.py: Parse(dir) => list [ Dir( ... ) ] (recursive)
- generate.py: Generate(site)
	- load source for site
	- compare to dest
	- generate or update items
	- keep links per type: last-n-page or page-cat-X (dict of list or dict of dict)
	- generate pages
- izumi.py: ConvertToHtml(izu)
- thumbnail.py: UrlForImage(file, quality, size)
- cache.py: Store(type, name, ref), or update. Cleanup()

----
20071020 Template System

I started using the Kid XML Templating system and I'm not very happy with it.
It's a fine piece of software and it does its job right. It's just not what I
really want. One one hand it means templates have to be XML whereas I want
templates to very free text. On the other hand by default it comes with a
limited set of serializers, most pro-eminently XML or HTML, that is it will
reformat documents accordingly -- and same here I just want something that
does text replacement in a template, not reformatting.

In the past I used the Django templating system with success and I liked it
overall. It's only weakness is that it doesn't do HTML encoding by default, but
that normal since it doesn't /have/ to be HTML templates. However Django does
much more than just templates and I don't need all the rest.

So I decided I will re-implement a minimalist templating system that does
exactly and only what I need. The specs follow.

Templates are free text with simple variable replacement.

Templates contain tags, which are enclosed in double-bracket pairs: [[ ... ]]
The first word after the opening bracket is the operation. Some tags can contain
content, in which case the content will be after the tag and before the next
[[end]] tag.

By default we'll have:
- [[# multi-line comment]]
- [[for x in list]] ... [[end]]
- [[include template.name]]
- [[if cond]] ... [[else]] ... [[end]]
- [[variable|filter|filter]]

Unknown tag operations will be expected to be variables to be replaced in place,
possibly after filtering.

Variable expansion should also accept field access, e.g. var.property.value.
For list, list.index (e.g. mylist.0); for dictionaries do a get; if property
is a function it evaluates it without arguments; otherwise it's a field/property
access.

If the template extension is ".html", variables will by default be html-encoded
unless a filter is present.

The expected filters will be:
- raw: The string is output as such. It's a no-op.
- html: HTML-encode the string. This is an implicit filter for .html templates.
- url: URL-encode the string.
- %: Any of the "printf"-like formatting for strings (e.g.: [[count|%02x]]

If you're familiar with Django, you'll notice this is basically the same
templating system except it doesn't have the notion of "top template" with
overridable blocks -- I prefer the usual top-down inclusion system.

There could be potentially more tag operations and more filters, for example
an "inc" filter, [[elseif]], date formatting, etc.


Implementation: we just want one class, Template(filename).
Included templates will be looked up in the same directory.
The Template constructor should parse the template and validate it and thow
a ParseException if needed.
Then Template.generate(dictionary) will serialize the template to a string.

Internally we shall parse the template into a structured tree.
A node can be:
- a list of nodes
- literal: content
- tag: tag name, parameters, optional node content
- variable: name list (e.g. x.y.z), filter list


Limitations: to keep things simply, we won't have variable expansion inside
tag blocks. E.g. you can't write [[for x in [[y.somelist]]]], nor can you
write [[myvar.[[selector]]]]. If we really had to, it wouldn't be too hard
to support, but my experience is that this is rarely needed and I don't see the
need for it -- I'm not writing the most universal templating system here, just
the minimum for what I need.
 

----
20071029 Template System, revisited

I finalized a first shot at the implementation of the template system.

I ended up implementing these tags:
- [[# comment]]
- [[for var in expr]] ... [[end]]
- [[if expr]] ... [[end]]
- [[expr]]
 
Note that "expr" is exactly that: a free string evaluated as a python expression.
For the "for", it's expected to return some iteratable (generator or list), for "if" it's
interpreted as a boolean using "not not x" and the last one mean that any unrecognized tag
is interpreted as an expression and then replaced as a string.

Note the lack of [[else]] and [[elif]]. These are not really needed, just use several "if" tags.

Initially I wanted to have filters a-la-Django for the free expressions, i.e. I wanted:
- [[expr|raw]]
- [[expr|html]]
- [[expr|url]]
With filter chaining, so you could say [[number|inc|html]].

However it's not really needed. Filters are just a Django idiom to call functions in a syntax
that doesn't allow it. Instead you can just have a global "inc()" function and call it.
I do want the raw/html/url encoding made explicit however, so I'm going to force them to
create expression evaluation. [[expr]] is going away and being replaced by:
- [[raw expr]]
- [[html  expr]]
- [[url expr]]

This also forces the template designer to make sure s/he's aware of when escaping is
done... or not.

Finally, I'm please with the free evaluation. It's much more elegant and convenient that
forcing a syntax for variables and "if" tags. It has two downsides: first it makes it easier
for a template designer to break the separation between code and template (i.e. the
dogma of having no code in templates) and second it can be too powerful and be exploited,
there's not much of a sandbox here. If you are developing a large-scale templating system
like Django, these matter a lot. In my case, I prefer the expressiveness since I'm both the
engine designer and the application designer, *and* my target is static sites generation.

----
20071029 Application

Now that the engine "framework" part of rig3 is more or less operational, even if very crude,
it's time to focus on the application at hand.

Each directory that contains a valid entry should have:
- an index.izu or an index.html
- zero or more photos

Right now I'll ignore directories without an index (it can be empty although
ideally I should have something.) Later I may add a more just for pictures.

The index.html is for importing old entries from the previous blog.
They are self contained and already contain pictures link as necessary. They
are just imported as-is. However the index.html also contain an "izu header"
on its first line (hidden in an html comment).
The izu parser should be able to handle that and generate the tags as
appropriate. Currently this header contains:
- The full date (YMD/HMS) of the original post
- The title
- A category (currently empty because of a bug but can be fixed). Or more
  exactly a list of category keywords.
- The author's name 

The izu index should have the following structure:
- An izu header on the first line (same tags).
	- The date & title are optional.
	- If not present, the defaults extracted from the directory name will be used.
  	- If present, they must override these defaults.
- Sections: "en" (english), "fr" (french), "images", "notes".
  	- Sections are optional. "en" is the default if not specified.
	- Sections are to be used in the template if present.

The purpose of the sections is to further separate layout from content:
even in the current HTML of the "old" wordpress blog, I have quite a bit of
layout encoded in each post. By separating the layout, I can change the way
sections are displayed after the fact, without having to edit back each entry.

Some sections might be specialized. For example I'd like to have an "images"
section with a list of images to display in this post and some layout logic that
can display the images differently (for example a slideshow vs a grid, etc.)

We'll start with a minimum set of izu tags and will expand later as needed.

For the structure:
- [izu:title:xyz]
- [izu:date:YYYY/MM/DD HH:MM:SS]
- [izu:author:xyz]
- [izu:cat:xyz1,xyz2,...] -- for catagories, can be empty
- [izu:refuse] -- don't serve this entry at all, can be used for temporary stuff
- [s:(en|fr|images|notes)] -- unknown sections should generate a warning
- [!-- .. --] -- comments

For izu tags (title, date, etc.), several version can be present. The last
one takes precedence. However it should be customary to just place them on
the first line.

For the presentation:
- __bold__
- ''italics''
- new lines for paragraphs
- * for lists, without indentation. A list ends when there's an empty line.
- ---- for an <hr>
- [title|url] -- for links or images.
- [rig:url:size] -- to generate a rig link

For list, I'll try something different. First I won't implement indentation
in the first shot (will have to be later, when needed.) And a buller-point list
will keep going till there's an empty line. That means each entry in the list
can be multi-line as long as it doesn't start with a star.

The [rig] tag will generate a thumbnail of the requested size with a link
onto the album (or the image?).

So this is the "design summary". Later I'll probably want to add some more tags,
support for block indentation and tables for example. That will wait till it
becomes needed though.

----
